# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import typing

class Fatiguing:
    r"""
    A fatigue-interference model.
    
    From the paper:
    
    > The idea is that ligands, which were bound but disconnected again from the cell,
    > don’t go back to their original state but are now considered "fatigued". They
    > then receive a different, much lower, rate for attaching to the cell again. This
    > way, the particles will have a chance to slowly detach again from the cell and
    > eventually, when fully detached, get the opportunity to explore different cells,
    > until they find the correct density.
    """
    total_ligands: int
    attachment_rate: float
    fatigued_attachment_rate: float
    deattachment_rate: float
    enter_rate: float
    inital_collision_factor: float
    obstruction_factor: float
    fatigued_obstruction_factor: float
    receptor_density: float
    def __new__(cls,total_ligands:int, attachment_rate:float, fatigued_attachment_rate:float, deattachment_rate:float, enter_rate:float, inital_collision_factor:float, obstruction_factor:float, fatigued_obstruction_factor:float, receptor_density:float): ...
    def simulate(self) -> FatiguingSimulationSingle:
        r"""
        Create a new single-particle simulation from this particle.
        """
        ...

    def simulate_many(self, n:int) -> FatiguingSimulation:
        r"""
        Create a new `n`-particle simulation from this particle.
        """
        ...

    def states(self) -> list[FatiguingState]:
        r"""
        Enumeration of all possible states for the particle.
        """
        ...

    def event_probabilities(self, state:FatiguingState) -> list[tuple[FatiguingState, float]]:
        r"""
        A list of probabilities for each possible next state.
        
        If a state is not contained in the list it can be assumed is 0.
        """
        ...

    def total_ligands(self) -> int:
        r"""
        The total amount of ligands the particle has.
        """
        ...

    def free_ligands(self, state:FatiguingState) -> int:
        r"""
        The total amount of free ligands in a state's particle.
        """
        ...


class FatiguingSimulation:
    def __new__(cls,particle:Fatiguing, n:int): ...
    def time(self) -> float:
        r"""
        The current time of the simulation.
        """
        ...

    def sample(self, samples:int) -> list[list[FatiguingState]]:
        r"""
        Takes `n` evenly spaced samples between `0` and [`Self::time`], using
        [`Self::states_at_time`].
        """
        ...

    def thetas(self, samples:int) -> list[float]:
        r"""
        Returns the attachment percentage (theta), at evenly spaced samples (using [`Self::sample`]).
        """
        ...

    def last_states(self) -> list[FatiguingState]:
        r"""
        Returns the states at the last point in the simulation.
        """
        ...

    def transition_histories(self) -> list[list[FatiguingTransition]]:
        r"""
        The transition histories of all simulations.
        
        Just in case, it is returned as a list of transition histories, not the other way around.
        """
        ...

    def last_theta(self) -> float:
        r"""
        Returns the attachment percentage at the last point in time (i.e., [`Self::time`]),
        commonly denoted with the greek theta (θ).
        """
        ...

    def advance_until(self, t:float) -> None:
        r"""
        Advances the simulation until a particular time.
        """
        ...


class FatiguingSimulationSingle:
    transition_history: list[FatiguingTransition]
    def __new__(cls,particle:Fatiguing): ...
    def time(self) -> float:
        r"""
        The current time of the simulation.
        """
        ...

    def last_state(self) -> FatiguingState:
        r"""
        The state of the particle at the last valid time.
        """
        ...

    def advance_until(self, t:float) -> None:
        ...


class FatiguingState:
    r"""
    # Invariants
    
    - `has_entered && has_exited == false`
    """
    has_entered: bool
    has_exited: bool
    attached_ligands: int
    fatigued_ligands: int

class FatiguingTransition:
    time: float
    target: FatiguingState

class Interfering:
    r"""
    A multi-valent particle that can attach and enter a host.
    
    Ligands obtruct the particle from entering, where for each additional attached ligand,
    the entering rate is decreased by a constant factor.
    """
    total_ligands: int
    attachment_rate: float
    deattachment_rate: float
    enter_rate: float
    inital_collision_factor: float
    obstruction_factor: float
    receptor_density: float
    def __new__(cls,total_ligands:int, attachment_rate:float, deattachment_rate:float, enter_rate:float, inital_collision_factor:float, obstruction_factor:float, receptor_density:float): ...
    def simulate(self) -> InterferingSimulationSingle:
        r"""
        Create a new single-particle simulation from this particle.
        """
        ...

    def simulate_many(self, n:int) -> InterferingSimulation:
        r"""
        Create a new `n`-particle simulation from this particle.
        """
        ...

    def states(self) -> list[InterferingState]:
        r"""
        Enumeration of all possible states for the particle.
        """
        ...

    def event_probabilities(self, state:InterferingState) -> list[tuple[InterferingState, float]]:
        r"""
        A list of probabilities for each possible next state.
        
        If a state is not contained in the list it can be assumed is 0.
        """
        ...

    def total_ligands(self) -> int:
        ...

    def free_ligands(self, state:InterferingState) -> int:
        r"""
        The total amount of free ligands in a state's particle.
        """
        ...


class InterferingSimulation:
    def __new__(cls,particle:Interfering, n:int): ...
    def time(self) -> float:
        r"""
        The current time of the simulation.
        """
        ...

    def sample(self, samples:int) -> list[list[InterferingState]]:
        r"""
        Takes `n` evenly spaced samples between `0` and [`Self::time`], using
        [`Self::states_at_time`].
        """
        ...

    def thetas(self, samples:int) -> list[float]:
        r"""
        Returns the attachment percentage (theta), at evenly spaced samples (using [`Self::sample`]).
        """
        ...

    def last_states(self) -> list[InterferingState]:
        r"""
        Returns the states at the last point in the simulation.
        """
        ...

    def transition_histories(self) -> list[list[InterferingTransition]]:
        r"""
        The transition histories of all simulations.
        
        Just in case, it is returned as a list of transition histories, not the other way around.
        """
        ...

    def last_theta(self) -> float:
        r"""
        Returns the attachment percentage at the last point in time (i.e., [`Self::time`]),
        commonly denoted with the greek theta (θ).
        """
        ...

    def advance_until(self, t:float) -> None:
        r"""
        Advances the simulation until a particular time.
        """
        ...


class InterferingSimulationSingle:
    transition_history: list[InterferingTransition]
    def __new__(cls,particle:Interfering): ...
    def time(self) -> float:
        r"""
        The current time of the simulation.
        """
        ...

    def last_state(self) -> InterferingState:
        r"""
        The state of the particle at the last valid time.
        """
        ...

    def advance_until(self, t:float) -> None:
        ...


class InterferingState:
    has_entered: bool
    attached_ligands: int

class InterferingTransition:
    time: float
    target: InterferingState

class MonoLiagndTransition:
    time: float
    target: MonoLigandState

class MonoLigand:
    r"""
    A particle that can attach to a receptor.
    
    This particle is a simple model of a ligand that can attach to a receptor. It has a binding
    strength that determines how likely it is to attach to a receptor, and a receptor density that
    determines how many receptors are available to attach to.
    """
    def __new__(cls,receptor_density:float, binding_strength:float, on_rate:float, off_rate:float): ...
    def simulate(self) -> MonoLigandSimulationSingle:
        r"""
        Create a new single-particle simulation from this particle.
        """
        ...

    def simulate_many(self, n:int) -> MonoLigandSimulation:
        r"""
        Create a new `n`-particle simulation from this particle.
        """
        ...

    def states(self) -> list[MonoLigandState]:
        r"""
        Enumeration of all possible states for the particle.
        """
        ...

    def event_probabilities(self, state:MonoLigandState) -> list[tuple[MonoLigandState, float]]:
        r"""
        A list of probabilities for each possible next state.
        
        If a state is not contained in the list it can be assumed is 0.
        """
        ...


class MonoLigandSimulation:
    def __new__(cls,particle:MonoLigand, n:int): ...
    def time(self) -> float:
        r"""
        The current time of the simulation.
        """
        ...

    def sample(self, samples:int) -> list[list[MonoLigandState]]:
        r"""
        Takes `n` evenly spaced samples between `0` and [`Self::time`], using
        [`Self::states_at_time`].
        """
        ...

    def thetas(self, samples:int) -> list[float]:
        r"""
        Returns the attachment percentage (theta), at evenly spaced samples (using [`Self::sample`]).
        """
        ...

    def last_states(self) -> list[MonoLigandState]:
        r"""
        Returns the states at the last point in the simulation.
        """
        ...

    def transition_histories(self) -> list[list[MonoLiagndTransition]]:
        r"""
        The transition histories of all simulations.
        
        Just in case, it is returned as a list of transition histories, not the other way around.
        """
        ...

    def last_theta(self) -> float:
        r"""
        Returns the attachment percentage at the last point in time (i.e., [`Self::time`]),
        commonly denoted with the greek theta (θ).
        """
        ...

    def advance_until(self, t:float) -> None:
        r"""
        Advances the simulation until a particular time.
        """
        ...


class MonoLigandSimulationSingle:
    transition_history: list[MonoLiagndTransition]
    def __new__(cls,particle:MonoLigand): ...
    def time(self) -> float:
        r"""
        The current time of the simulation.
        """
        ...

    def last_state(self) -> MonoLigandState:
        r"""
        The state of the particle at the last valid time.
        """
        ...

    def advance_until(self, t:float) -> None:
        ...


class MonoLigandState:
    is_attached: bool
    def toggle(self) -> MonoLigandState:
        ...


class MultiLiagndTransition:
    time: float
    target: MultiLigandState

class MultiLigand:
    r"""
    A particle with many ligands, where each one can attach and dettach from the host.
    
    # Invariants
    - `on_rates.len() == off_rates.len()`
    """
    def __new__(cls,receptor_density:float, binding_strength:float, on_rates:typing.Sequence[float], off_rates:typing.Sequence[float]): ...
    def simulate(self) -> MultiLigandSimulationSingle:
        r"""
        Create a new single-particle simulation from this particle.
        """
        ...

    def simulate_many(self, n:int) -> MultiLigandSimulation:
        r"""
        Create a new `n`-particle simulation from this particle.
        """
        ...

    def states(self) -> list[MultiLigandState]:
        r"""
        Enumeration of all possible states for the particle.
        """
        ...

    def event_probabilities(self, state:MultiLigandState) -> list[tuple[MultiLigandState, float]]:
        r"""
        A list of probabilities for each possible next state.
        
        If a state is not contained in the list it can be assumed is 0.
        """
        ...

    def total_ligands(self) -> int:
        ...


class MultiLigandSimulation:
    def __new__(cls,particle:MultiLigand, n:int): ...
    def time(self) -> float:
        r"""
        The current time of the simulation.
        """
        ...

    def sample(self, samples:int) -> list[list[MultiLigandState]]:
        r"""
        Takes `n` evenly spaced samples between `0` and [`Self::time`], using
        [`Self::states_at_time`].
        """
        ...

    def thetas(self, samples:int) -> list[float]:
        r"""
        Returns the attachment percentage (theta), at evenly spaced samples (using [`Self::sample`]).
        """
        ...

    def last_states(self) -> list[MultiLigandState]:
        r"""
        Returns the states at the last point in the simulation.
        """
        ...

    def transition_histories(self) -> list[list[MultiLiagndTransition]]:
        r"""
        The transition histories of all simulations.
        
        Just in case, it is returned as a list of transition histories, not the other way around.
        """
        ...

    def last_theta(self) -> float:
        r"""
        Returns the attachment percentage at the last point in time (i.e., [`Self::time`]),
        commonly denoted with the greek theta (θ).
        """
        ...

    def advance_until(self, t:float) -> None:
        r"""
        Advances the simulation until a particular time.
        """
        ...


class MultiLigandSimulationSingle:
    transition_history: list[MultiLiagndTransition]
    def __new__(cls,particle:MultiLigand): ...
    def time(self) -> float:
        r"""
        The current time of the simulation.
        """
        ...

    def last_state(self) -> MultiLigandState:
        r"""
        The state of the particle at the last valid time.
        """
        ...

    def advance_until(self, t:float) -> None:
        ...


class MultiLigandState:
    r"""
    # Invariants
    - `attached_ligands <= total_ligands`
    """
    total_ligands: int
    attached_ligands: int
    def bind(self) -> MultiLigandState:
        ...

    def unbind(self) -> MultiLigandState:
        ...


