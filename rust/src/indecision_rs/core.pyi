# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import typing

class Interfering:
    r"""
    A multi-valent particle that can attach and enter a host.
    
    Ligands obtruct the particle from entering, where for each additional attached ligand,
    the entering rate is decreased by a constant factor.
    """
    def __new__(cls,receptor_density:float, binding_strength:float, on_rates:typing.Sequence[float], off_rates:typing.Sequence[float], enter_rate:float, obstruction_factor:float): ...
    def simulate(self) -> InterferingSimulationSingle:
        r"""
        Create a new single-particle simulation from this particle.
        """
        ...

    def simulate_many(self, n:int) -> InterferingSimulation:
        r"""
        Create a new `n`-particle simulation from this particle.
        """
        ...

    def states(self) -> list[InterferingState]:
        ...

    def event_probabilities(self, state:InterferingState) -> list[tuple[InterferingState, float]]:
        r"""
        A list of probabilities for each possible next state.
        
        If a state is not contained in the list it can be assumed is 0.
        """
        ...

    def total_ligands(self) -> int:
        ...


class InterferingSimulation:
    def __new__(cls,particle:Interfering, n:int): ...
    def sample(self, samples:int) -> list[list[InterferingState]]:
        ...

    def thetas(self, samples:int) -> list[float]:
        ...

    def last_theta(self) -> float:
        ...

    def advance_until(self, t:float) -> None:
        ...


class InterferingSimulationSingle:
    transition_history: list[InterferingTransition]
    def __new__(cls,particle:Interfering): ...
    def advance_until(self, t:float) -> None:
        ...


class InterferingState:
    has_entered: bool
    attached_ligands: int

class InterferingTransition:
    time: float
    target: InterferingState

class MonoLiagndTransition:
    time: float
    target: MonoLigandState

class MonoLigand:
    r"""
    A particle that can attach to a receptor.
    
    This particle is a simple model of a ligand that can attach to a receptor. It has a binding
    strength that determines how likely it is to attach to a receptor, and a receptor density that
    determines how many receptors are available to attach to.
    """
    def __new__(cls,receptor_density:float, binding_strength:float, on_rate:float, off_rate:float): ...
    def simulate(self) -> MonoLigandSimulationSingle:
        r"""
        Create a new single-particle simulation from this particle.
        """
        ...

    def simulate_many(self, n:int) -> MonoLigandSimulation:
        r"""
        Create a new `n`-particle simulation from this particle.
        """
        ...

    def states(self) -> list[MonoLigandState]:
        ...

    def event_probabilities(self, state:MonoLigandState) -> list[tuple[MonoLigandState, float]]:
        r"""
        A list of probabilities for each possible next state.
        
        If a state is not contained in the list it can be assumed is 0.
        """
        ...


class MonoLigandSimulation:
    def __new__(cls,particle:MonoLigand, n:int): ...
    def sample(self, samples:int) -> list[list[MonoLigandState]]:
        ...

    def thetas(self, samples:int) -> list[float]:
        ...

    def last_theta(self) -> float:
        ...

    def advance_until(self, t:float) -> None:
        ...


class MonoLigandSimulationSingle:
    transition_history: list[MonoLiagndTransition]
    def __new__(cls,particle:MonoLigand): ...
    def advance_until(self, t:float) -> None:
        ...


class MonoLigandState:
    is_attached: bool
    def toggle(self) -> MonoLigandState:
        ...


class MultiLiagndTransition:
    time: float
    target: MultiLigandState

class MultiLigand:
    r"""
    A particle with many ligands, where each one can attach and dettach from the host.
    
    # Invariants
    - `on_rates.len() == off_rates.len()`
    """
    def __new__(cls,receptor_density:float, binding_strength:float, on_rates:typing.Sequence[float], off_rates:typing.Sequence[float]): ...
    def simulate(self) -> MultiLigandSimulationSingle:
        r"""
        Create a new single-particle simulation from this particle.
        """
        ...

    def simulate_many(self, n:int) -> MultiLigandSimulation:
        r"""
        Create a new `n`-particle simulation from this particle.
        """
        ...

    def states(self) -> list[MultiLigandState]:
        ...

    def event_probabilities(self, state:MultiLigandState) -> list[tuple[MultiLigandState, float]]:
        r"""
        A list of probabilities for each possible next state.
        
        If a state is not contained in the list it can be assumed is 0.
        """
        ...

    def total_ligands(self) -> int:
        ...


class MultiLigandSimulation:
    def __new__(cls,particle:MultiLigand, n:int): ...
    def sample(self, samples:int) -> list[list[MultiLigandState]]:
        ...

    def thetas(self, samples:int) -> list[float]:
        ...

    def last_theta(self) -> float:
        ...

    def advance_until(self, t:float) -> None:
        ...


class MultiLigandSimulationSingle:
    transition_history: list[MultiLiagndTransition]
    def __new__(cls,particle:MultiLigand): ...
    def advance_until(self, t:float) -> None:
        ...


class MultiLigandState:
    r"""
    # Invariants
    - `attached_ligands <= total_ligands`
    """
    total_ligands: int
    attached_ligands: int
    def bind(self) -> MultiLigandState:
        ...

    def unbind(self) -> MultiLigandState:
        ...


