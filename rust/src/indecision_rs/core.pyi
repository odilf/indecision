# This file is automatically generated by pyo3_stub_gen
# ruff: noqa: E501, F401

import typing

class Interfering:
    r"""
    A multi-valent particle that can attach and enter a host. 
    
    Ligands obtruct the particle from entering, where for each additional attached ligand,
    the entering rate is decreased by a constant factor.
    """
    def __new__(cls,receptor_density:float, binding_strength:float, on_rates:typing.Sequence[float], off_rates:typing.Sequence[float], enter_rate:float, obstruction_factor:float): ...
    def max_ligands(self) -> int:
        ...

    def simulate(self) -> InterferingSimulationSingle:
        ...

    def simulate_many(self, n:int) -> InterferingSimulation:
        ...


class InterferingSimulation:
    def __new__(cls,particle:Interfering, n:int): ...
    def sample(self, samples:int) -> list[list[InterferingState]]:
        ...

    def thetas(self, samples:int) -> list[float]:
        ...

    def last_theta(self) -> float:
        ...

    def advance_until(self, t:float) -> None:
        ...


class InterferingSimulationSingle:
    transition_history: list[InterferingTransition]
    def __new__(cls,particle:Interfering): ...
    def advance_until(self, t:float) -> None:
        ...


class InterferingState:
    ...

class InterferingTransition:
    time: float
    state: InterferingState

class MonoLiagndTransition:
    time: float
    state: MonoLigandState

class MonoLigand:
    r"""
    A particle that can attach to a receptor.
    
    This particle is a simple model of a ligand that can attach to a receptor. It has a binding
    strength that determines how likely it is to attach to a receptor, and a receptor density that
    determines how many receptors are available to attach to.
    """
    def __new__(cls,receptor_density:float, binding_strength:float, on_rate:float, off_rate:float): ...
    def simulate(self) -> MonoLigandSimulationSingle:
        ...

    def simulate_many(self, n:int) -> MonoLigandSimulation:
        ...


class MonoLigandSimulation:
    def __new__(cls,particle:MonoLigand, n:int): ...
    def sample(self, samples:int) -> list[list[MonoLigandState]]:
        ...

    def thetas(self, samples:int) -> list[float]:
        ...

    def last_theta(self) -> float:
        ...

    def advance_until(self, t:float) -> None:
        ...


class MonoLigandSimulationSingle:
    transition_history: list[MonoLiagndTransition]
    def __new__(cls,particle:MonoLigand): ...
    def advance_until(self, t:float) -> None:
        ...


class MonoLigandState:
    is_attached: bool
    def toggle(self) -> MonoLigandState:
        ...


class MultiLiagndTransition:
    time: float
    state: MultiLigandState

class MultiLigand:
    r"""
    # Invariants
    - `on_rates.len() == off_rates.len()`
    """
    def __new__(cls,receptor_density:float, binding_strength:float, on_rates:typing.Sequence[float], off_rates:typing.Sequence[float]): ...
    def max_ligands(self) -> int:
        ...

    def simulate(self) -> MultiLigandSimulationSingle:
        ...

    def simulate_many(self, n:int) -> MultiLigandSimulation:
        ...


class MultiLigandSimulation:
    def __new__(cls,particle:MultiLigand, n:int): ...
    def sample(self, samples:int) -> list[list[MultiLigandState]]:
        ...

    def thetas(self, samples:int) -> list[float]:
        ...

    def last_theta(self) -> float:
        ...

    def advance_until(self, t:float) -> None:
        ...


class MultiLigandSimulationSingle:
    transition_history: list[MultiLiagndTransition]
    def __new__(cls,particle:MultiLigand): ...
    def advance_until(self, t:float) -> None:
        ...


class MultiLigandState:
    r"""
    # Invariants
    - `attached_ligands <= max_ligands`
    """
    max_ligands: int
    attached_ligands: int
    def bind(self) -> MultiLigandState:
        ...

    def unbind(self) -> MultiLigandState:
        ...


